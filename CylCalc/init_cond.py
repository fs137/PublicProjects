from node import *
from regen import *
def overlapping(x1,subsets,x3d_,tol=1e-6):
	for j in range(len(subsets)):
		for jj in range(len(subsets[j])):
			idjj = subsets[j][jj]
			if idjj in x3d_:
				disp = x1-x3d_[idjj]
				dispsq =np.dot(disp,disp)
				if dispsq<4-tol:
					return True
	return False

def normsq(x):
	return np.dot(x,x)

def cyl_constr(v2,v0,v1,Rsq):
	d20 = v2-v0
	d21 = v2-v1
	return np.array([normsq(d20)-4,normsq(d21)-4,normsq(v2[:2])-Rsq])

z_hat = np.array([0,0,1])
def cyl_gen(v0,v1):
	Rsq = normsq(v0[:2])
	R = np.sqrt(Rsq)
	Rinv = 1./R
	diff = v1-v0
	phi_hat = np.array([-v0[1],v0[0],0])*Rinv
	diff_phi = np.dot(phi_hat,diff)
	v2_guess=phi_hat*(0.5*diff_phi-hrt3*diff[2])+z_hat*(0.5*diff[2]+hrt3*diff_phi)+v0
	v2r = scipy.optimize.root(cyl_constr,v2_guess,(v0,v1,Rsq))
	if v2r.success:
		return v2r.x
	else:
		print "Warning: failed to compute vector generated by ("+str(v0)+","+str(v1)+")"
		return None

def frozen_dec(ud_graph,states='all_frozen'):
	att_name = 'frozen'
	if np.any(states=='all_frozen'):
		states = -np.ones(ud_graph.Np,dtype=int)
	for j in range(ud_graph.Np):
		ud_graph.nodes[j].att[att_name]=str(states[j])
	return [ud_graph,att_name]

def generate_droplet(R_cyl,drop_shape_pars,output_file="f.0",dec=None):
	[R_drop,angle_drop] = drop_shape_pars
	R_eff = R_cyl+1
	R_effsq=R_eff**2
	# Generators of a crystal oriented at angle_drop:
	v0 = np.zeros(3)
	v0[2]=2*np.sin(angle_drop)
	vxy = 2*np.cos(angle_drop)
	origin = np.array([R_eff,0,0])
	theta0 = 2*np.arcsin(0.5*vxy/R_eff)
	v0[0]=R_eff*np.cos(theta0)
	v0[1]=R_eff*np.sin(theta0)

	v1_rel = lambda v: np.array([normsq(v-v0)-4,normsq(v-origin)-4,normsq(v[:2])-R_effsq])
	v1_guess = v0-origin
	v1_guess[1:] = np.array([0.5*v1_guess[1]-hrt3*v1_guess[2],0.5*v1_guess[2]+hrt3*v1_guess[1]])
	v1r = scipy.optimize.root(v1_rel,v1_guess)
	if v1r.success:
		v1 = v1r.x
	else:
		print "Error: unable to compute first nontrivial lattice generator from v0 on cylinder of radius "+str(R_eff)
		return None
	v0_2d = np.array([theta0*R_eff,v0[2]])
	theta1 = np.arcsin(v1[1]/R_eff)
	if v1[0]>0:
		pass
	else:
		theta1 = np.pi*(int(theta1>0)-int(theta1<0))-theta1
	v1_2d = np.array([R_eff*theta1,v1[2]])
	ref_lattice = lattice_graph('tri2d',R_drop)
	drop_graph = graph()
	drop_content = {}
	drop_content[(0,0)]=0
	drop_graph.add_node(0)
	for j in range(ref_lattice.Np):
		latindex = ref_lattice.nodes[j].att['latindex']
		ref_lattice.nodes[j].att['pos2d']=v0_2d*latindex[0]+v1_2d*latindex[1]
	bdry = [0]
	x3d_ = {}
	x3d_[0]=np.array([R_eff,0,0])
	invR = 1./R_eff
	while len(bdry)>0:
		nbdry = []
		for j in range(len(bdry)):
			idj = bdry[j]
			nj = ref_lattice.id2n[idj]
			for nn in ref_lattice.nodes[nj].nbors:
				idnn = ref_lattice.nodes[nn].id
				latindex = ref_lattice.nodes[nn].att['latindex']
				if latindex in drop_content:
					edge = (min(idj,idnn),max(idj,idnn))
					if edge in drop_graph.edges:
						pass
					else:
						drop_graph.add_edge(idj,idnn)
				else:
					x2d = ref_lattice.nodes[nn].att['pos2d']
					# Compute 3D coordinates of idnn:
					theta = x2d[0]*invR
					x3d__new = np.array([R_eff*np.cos(theta),R_eff*np.sin(theta),x2d[1]])
					if not overlapping(x3d__new,[bdry,nbdry],x3d_):
						x3d_[idnn]=x3d__new
						nbdry.append(idnn)
						drop_content[latindex]=idnn
						drop_graph.add_node(idnn)
						drop_graph.add_edge(idj,idnn)
		bdry=nbdry
	if dec!=None:
		# Decorate the droplet graph
		[drop_graph,att_name] = dec(drop_graph)
	if output_file!=None:
		ofile = open(output_file,"w")
		for id_ in x3d_:
			x = x3d_[id_]
			if dec==None:
				line = str(id_)+" "+str(x[0])+" "+str(x[1])+" "+str(x[2])+"\n"
			else:
				line = str(id_)+" "+str(x[0])+" "+str(x[1])+" "+str(x[2])+" "+str(drop_graph.nodes[drop_graph.id2n[id_]].att[att_name])+"\n"
			ofile.write(line)
		ofile.close()
	x3d__array = np.zeros([len(x3d_),3])
	x3d__keys = x3d_.keys()
	for j in range(len(x3d__keys)):
		x3d__array[j,:]=x3d_[x3d__keys[j]]
	return x3d__array

local_path_to_data = "../../esim/depl/whw/nbor_list/frozen_part/data"
# Note: if no trial name is specified, consider assigning a random one to avoid 
#	potential confusion
def droplet_ic(sim_pars,drop_shape_pars,sim_name,trial_name=None):
	if trial_name==None:
		trial_name = np.binary_repr(np.random.randint(10000))
		print "No trial name specified. Assigning the (computer friendly) name "+trial_name
	[R_cyl,depl_str,dpr,pdiffuse,rho_eq,T_max,dt,T_frame] = sim_pars
	pbc_flag=1 # (set by default, but only because I know pbc works in frozen_part)
	data_folder = local_path_to_data+"/"+sim_name
	mkdir_s(data_folder)
	trial_folder = data_folder+"/"+trial_name
	mkdir_s(trial_folder)
	# Generate coordinates
	f0name = trial_folder+"/f.0"
	# def generate_droplet(R_cyl,drop_shape_pars,output_file="f.0",dec=None)
	print "Generating droplet"
	x0=generate_droplet(R_cyl,drop_shape_pars,output_file=f0name,dec=frozen_dec)
	zmin = min(x0[:,2])
	zmax = max(x0[:,2])
	pfolder = local_path_to_data+"/parameters/"+sim_name
	mkdir_s(pfolder)
	pfile = pfolder+"/"+trial_name+".par"
	pfile = open(pfile,"w")
	buf = 2*np.pi*(R_cyl+1)
	print "Writing parameter file"
	pfile.write("-1\n"+str(R_cyl)+"\n"+str(zmin-buf)+" "+str(zmax+buf)+"\n"+str(depl_str)+"\n"+str(dpr)+"\n"+str(pdiffuse)+"\n"+str(rho_eq)+"\n"+str(pbc_flag)+"\n"+str(T_max)+"\n"+str(dt)+"\n"+str(T_frame))
	pfile.close()


def minimal_ring(anc_shape_pars,offset=None):
	[v2d,na,nb,R_eff]=anc_shape_pars
	# Determine canonical va, vb, vls
	# 	and a minimal closed ring (i.e. n1, n2, nls such that v1 and v2 have large phi components and nls*vls has a positive phi component as well
	vabc = np.zeros([3,2])
	vabc[0,:]=v2d[:2]
	vabc[1,:]=v2d[2:4]
	if np.dot(v2d[:2],v2d[2:4])>0:
		vabc[2,:]=v2d[:2]-v2d[2:4]
		ncb = -1
	else:
		vabc[2,:]=v2d[:2]+v2d[2:4] 
		ncb = 1
	v2d_phi = np.zeros(3,dtype=graded_int)
	for j in range(3):
		v2d_phi[j]['score']=np.abs(vabc[j,0])
		v2d_phi[j]['int']=j
	v2d_phi=np.sort(v2d_phi,0)
	i1 = v2d_phi[1]['int']
	i2 = v2d_phi[2]['int']
	i1i2 = (i1,i2)
	v1 = vabc[v2d_phi[1]['int'],:]
	v2 = vabc[v2d_phi[2]['int'],:]
	# Sanity check
	circ = 2*np.pi*R_eff
	traversed=np.abs(na*v2d[0]+nb*v2d[2]+v2d[4])
	if np.abs(circ-traversed)>1e-5:
		print "Error: mismatch between traversed displacement and cylinder circumference: "+str(circ-traversed)
	ns = np.zeros(2,dtype=int)
	if i1i2==(0,1) or i1i2==(1,0):
		# Unlikely situation
		if i1==0:
			ns[0] = na
			ns[1] = nb
			nls = 1
		else:
			ns[0]=nb
			ns[1]=na
			nls=1
	elif i1i2==(0,2) or i1i2==(2,0):
		# Also unlikely
		# n1*va+n2*(va\pm vb) = na*va+nb*vb => n1+n2= na, n2 = \pm nb
		# n1*(va\pm vb)+n2*va = na*va+nb*vb => n1+n2= na, \pm n1 = nb
		if i1==0:
			ns[1]=ncb*nb
			ns[0]=na-ns[1]
		else:
			ns[0]=ncb*nb
			ns[1]=na-ns[0]
	elif i1i2==(1,2) or i1i2==(2,1):
		# Most likely
		if i1==1:
			# n1*vb+n2*(va+ncb*vb) = na*va+nb*vb => n1+ncb*n2 = nb, n2 = na
			ns[1]=na
			ns[0]=nb-ncb*ns[1]
		else:
			# n1*(va+ncb*vb)+n2*vb = na*va+nb*vb => n1 = na, ncb*n1+n2 = nb
			ns[0]=na
			ns[1]=nb-ncb*ns[0]
	x2d = np.zeros([abs(ns[0])+abs(ns[1])+1,2])
	if ns[0]<0:
		v1=-v1
		ns[0]=-ns[0]
	if ns[1]<0:
		v2=-v2
		ns[1]=-ns[1]
	for j in range(1,1+abs(ns[0])):
		x2d[j,:]=x2d[j-1,:]+v1
	for j in range(1+abs(ns[0]),1+abs(ns[0])+abs(ns[1])):
		x2d[j,:]=x2d[j-1,:]+v2
	if np.any(offset!=None):
		x2d+=offset
	x3d_ = np.zeros([len(x2d),3])
	for j in range(len(x2d)):
		x3d_[j,:]=x3d(x2d[j,:],R_eff)
	# Check that the first and last nodes are tangent
	d1n = np.linalg.norm(x3d_[-1,:]-x3d_[0,:])
	if abs(d1n-2)>1e-4:
		print "Anomalous distance between first and last particles in minimal ring: "+str(d1n)
	return x3d_


# Ways of generating a ring: 
#	curve index, type, width/thickness parameter
def generate_ring(R_cyl,ring_shape_pars,output_file,dec=None,offset=None):
	# Start with a patch that is large enough to accommodate the specified ring shape:
	# Grow or unpack the ring structure from specified ring shape
	# Add the decoration (if any)
	# Save the configuration to the output file
	R_eff = R_cyl+1
	R_effsq = R_eff**2
	# Obtain curve parameters from curve_index
	#	Define a minimal curve
	x0 = ring_shape_pars[0](ring_shape_pars[1:],offset=offset)
	# Check if specified output file already exists, and check for overlaps with existing points
	try:
		ofile = open(output_file,"r")
		x_init = []
		for line in ofile:
			line = line.split()
			x_init.append([float(line[j]) for j in range(1,4)])
		x_init = np.array(x_init)
		ofile.close()
		# Check for overlaps
		overlapping = False
		x0_no = []
		for j in range(len(x0)):
			for jj in range(len(x_init)):
				djjj = x_init[jj,:]-x0[j,:]
				djjj = np.dot(djjj,djjj)
				if djjj<4: # Presumes radius 1
					overlapping = True
					break
			if not overlapping:
				x0_no.append(x0[j,:])
		x0 = np.array(x0_no)
		if overlapping:
			print "Warning: proposed coordinates overlap with existing pointset"
	except:
		pass
	try:
		ofile = open(output_file,"a")
		for j in range(len(x0)):
			if dec!=None:
				line = str(j)+" "+str(x0[j,0])+" "+str(x0[j,1])+" "+str(x0[j,2])+" "+str(dec)+"\n"
			else:
				line = str(j)+" "+str(x0[j,0])+" "+str(x0[j,1])+" "+str(x0[j,2])+"\n"
			ofile.write(line)
		ofile.close()
	except:
		print "Unable to open "+str(output_file)
	return x0

def generate_ring_ic(sim_pars,ring_shape_pars,sim_name,trial_name):
	[R_cyl,extra_len,depl_str,dpr,pdiffuse,rho_eq,T_max,dt,T_frame]=sim_pars
	pbc_flag=1 # (set by default, but only because I know pbc works in frozen_part)
	data_folder = local_path_to_data+"/"+sim_name
	mkdir_s(data_folder)
	trial_folder = data_folder+"/"+trial_name
	mkdir_s(trial_folder)
	# Generate coordinates
	f0name = trial_folder+"/f.0"
	x0 = generate_ring(R_cyl,ring_shape_pars,output_file=f0name,dec=-1)
	buf = 2*np.pi*(R_cyl+1)
	zmin = min(x0[:,2])-buf-extra_len
	zmax = max(x0[:,2])+buf+extra_len
	pfolder = local_path_to_data+"/parameters/"+sim_name
	mkdir_s(pfolder)
	pfile = pfolder+"/"+trial_name+".par"
	pfile = open(pfile,"w")
	print "Writing parameter file"
	pfile.write("-1\n"+str(R_cyl)+"\n"+str(zmin)+" "+str(zmax)+"\n"+str(depl_str)+"\n"+str(dpr)+"\n"+str(pdiffuse)+"\n"+str(rho_eq)+"\n"+str(pbc_flag)+"\n"+str(T_max)+"\n"+str(dt)+"\n"+str(T_frame))
	pfile.close()

def generate_ring_pair(sim_pars,ring_shape_pars,sim_name,trial_name,offset=np.array([0,10])):
	[R_cyl,extra_len,depl_str,dpr,pdiffuse,rho_eq,T_max,dt,T_frame]=sim_pars
	buf = 2*np.pi*(R_cyl+1)
	pbc_flag=1 # (set by default, but only because I know pbc works in frozen_part)
	data_folder = local_path_to_data+"/"+sim_name
	mkdir_s(data_folder)
	trial_folder = data_folder+"/"+trial_name
	mkdir_s(trial_folder)
	# Generate coordinates
	f0name = trial_folder+"/f.0"
	x0 = generate_ring(R_cyl,ring_shape_pars[0],output_file=f0name,dec=-1)
	x1 = generate_ring(R_cyl,ring_shape_pars[0],output_file=f0name,dec=-1,offset=offset)
	zmin = min(x0[:,2])-minsep-buf-extra_len
	zmax = max(x1[:,2])+minsep+buf+extra_len
	pfolder = local_path_to_data+"/parameters/"+sim_name
	mkdir_s(pfolder)
	pfile = pfolder+"/"+trial_name+".par"
	pfile = open(pfile,"w")
	print "Writing parameter file"
	pfile.write("-1\n"+str(R_cyl)+"\n"+str(zmin)+" "+str(zmax)+"\n"+str(depl_str)+"\n"+str(dpr)+"\n"+str(pdiffuse)+"\n"+str(rho_eq)+"\n"+str(pbc_flag)+"\n"+str(T_max)+"\n"+str(dt)+"\n"+str(T_frame))
	pfile.close()
